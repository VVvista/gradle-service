1.项目
project对应的方法

2.任务
task对应的方法

3.属性
3.1扩展属性
ext
1.两种定义方式
//等同于ext.a
ext {
    a='a'
}
project.ext.a="a"
2.调用-使用ext命名空间访问属性
println project.ext.a //(project/ext可省略)
3.rootProject中定义的属性可在子project中调用
println rootProject.someOtherProp

3.2gradle属性
gradle属性可以通过在gradle.properties文件中声明直接添加到项目中，文件必须位于$user_home/.gradle目录，或者项目的根目录下
即使有多个项目，但是每个用户只能有一个gradle属性文件在$user_home/.gradle目录下，在该文件中生命的属性对所有的项目可用。

#gradle.properties 文件：
exampleProp=myValue
someOtherProp=455

#访问变量
println "second:$someOtherProp"
println someOtherProp

3.3声明属性的其他方式
* 项目属性通过 —P 命令行选项提供
* 系统属性通过 -D 命令行选项提供
* 环境属性按照下面的模式提供
ORG_GRADLE_PROJECT_propertyName=someValue

4.使用task
默认情况下创建的task的为org.gradle.api.DefaultTask类型，而org.gradle.api.DefaultTask是org.gradle.api.Task的标准实现，而DefaultTas
的属性是私有的，仅能通过getter、setter方法调用，但可以使用groovy的语法直接使用属性名调用，groovy的底层为其调用其方法
```
/**
 * {@code DefaultTask} is the standard {@link Task} implementation. You can extend this to implement your own task types.
 */
@NoConventionMapping
public class DefaultTask extends AbstractTask 

public interface Task extends Comparable<Task>, ExtensionAware {
```
4.1项目版本管理
* 用于修改项目版本
* 用于部署war包
4.2生命task动作
* doFirst
* doLast
* 给现有的task 添加动作
```
task printVersion  {
    doFirst {
        println "before reading the project version"
    }
    doLast {
        println "version:$version"
    }
}
printVersion.doFirst{ println "First action!"}
printVersion.doLast{println "last action !!"}
// 输出结果
First action!
before reading the project version
version:1.1-SNAPSHOT
last action !!
```
* 访问DefaultTask属性
改进版本号打印方式-logger
task提供了基于org.slf4j.Logger的getLogger接口，除了实现常规范围的日志级别（debug error info trace warn）外，gradle还增加了一写额外的日志级别。
通过task的方法（groovy中直接使用属性名访问该方法，groovy底层调用getLogger方法）直接访问logger示例
```
// project task Script均有该 getLogger方法
    /**
     * <p>Returns the logger for this task. You can use this in your build file to write log messages.</p>
     *
     * @return The logger. Never returns null.
     */
    @Internal
    Logger getLogger();

// org.gradle.api.logging.Logger
/**
 * <p>An extension to the SLF4J {@code Logger} interface, which adds the {@code quiet} and {@code lifecycle} log
 * levels.</p>
 *
 * <p>You can obtain a {@code Logger} instance using {@link Logging#getLogger(Class)} or {@link
 * Logging#getLogger(String)}. A {@code Logger} instance is also available through {@link
 * org.gradle.api.Project#getLogger()}, {@link org.gradle.api.Task#getLogger()} and {@link
 * org.gradle.api.Script#getLogger()}.</p>
 */
public interface Logger extends org.slf4j.Logger 

```
示例：
```
task printVersion  {
    doLast {
        logger.quiet "version:$version"
    }
}
```

group description ，可以很好的帮助用户较容易的识别task作用
group：定义task的逻辑分组
description：描述任务的作用
```
// 方式1
task printVersion(group: "versioning",description:"println project version") {
    doLast {
        logger.quiet "version:$version"
    }
}
// 方式2
task printVersion {
    group="versioning" // groovy 底层调用的setGroup方法
    description="println project version" // groovy 底层调用setDescription 方法
    doLast {
        logger.quiet "version:$version"
    }
}

#运行./gradlew tasks 可以看到正确的分组及描述信息
Versioning tasks
----------------
printVersion - println project version

```
* 定义task依赖
dependsOn 生命依赖一个或多个task
```
task first{ println "first"}
task second{println "second"}
task printVersion(dependsOn:[second,first]){
        logger.quiet "version:$version"

}
task third{println "third"}
third.dependsOn printVersion
#./gradlew third
first
second
version:1.1-SNAPSHOT
third

```
注意： - task的执行顺序是不一定，执行顺序不是依照dependsOn:[second,first]（并不保证先执行second 再执行first）
- dependsOn只是定义了所依赖的task需要先执行，而没有定义其该如何执行
- 执行殊勋由task的输入或输出规范自动定义的，该设计好处
  1.不需要知道整个task的依赖链上的关系是否发生改变，提高代码的可维护性和避免潜在的破坏
  2.没有严格的执行顺序，即支持task的并行执行，可以节省task的构建执行时间

* 终结器task ??
```
task first{ println "first"}
task second{println "second"}
first.finalizedBy second
#./gradlew first
first
second

```

* 添加任意代码
** 以控制项目版本号为例
groovy只需要声明属性，在编译中字节码文件自动生成getter setter 方法，在运行时可以直接使用
```

class ProjectVersion {
    int major
    int minor

    boolean release

    ProjectVersion(int major, int minor, int min) {
        this.major = major
        this.minor = minor
        this.release = false
    }

    ProjectVersion(int major, int minor,  boolean release) {
        this.major = major
        this.minor = minor
        this.release = release
    }


    @Override
    public String toString() {
        return "$major.$minor.${release ? '' : '-SNAPSHOT'}"
    }
}
def version = new ProjectVersion(1, 0, 0)
task printVersion << {
    println(" >>>>>> the verson is ${version}")
}
```

* 理解task配置
** 创建名为version.properties文件，并为每个版本的类别如主版本和次版本设置不同属性
```
major=0
minor=1
release=true

```
** 添加task配置块
编写task 配置
```

ext.versionFile=file('version.properties')
task loadVersion{
    project.version=readVersion()
}

ProjectVersion readVersion(){
    logger.quiet 'reading the version file'
    if(!versionFile.exists()){
        //throw new GradleScriptException("required version file does not exist:${versionFile.canonicalPath}")
    }
    Properties versionProps=new Properties()
    versionFile.withInputStream{
        stream->versionProps.load(stream)
    }
    new ProjectVersion(versionProps.major.toInteger(),versionProps.minor.toInteger(),
            versionProps.release.toBoolean())

}
task printVersion << {
    println(" >>>>>> the verson is ${version}")
}

```
* gradle的生命构建周期

* task的输入和输出

* 编译和自定义task ？？
 * 声明task规则？？？
 首先需要获得对TaskContainer的引用，然后可调用其addRule(String, Closure) 方法，通过project的getTasks()方法获取 TaskContainer引用；
 使用task规则，实现上线动作：
```
// 使用 taskContainer 添加规则
tasks.addRule("Pattern: increment<Classifier>Version - Increments the project version.") {
    String taskName ->
        if (taskName.startsWith('increment') && taskName.endsWith('Version')) {
            task(taskName) << {  // 符合命名模式的task动态添加doLast方法
                String classifier = (taskName - 'increment' - 'Version'.toLowerCase())  // 提取
                String currentVersion = version.toString()

                switch (classifier) {
                    case 'major': ++version.major
                        break
                    case 'minor': ++version.minor
                        break
                    default: throw new GradleException("Invalid version type '$classifier', Allowed " +
                            " types: ['Major','Minor']")
                }

                String newVersion = version.toString()
                logger.info "Incrementing $classifier project version: $currentVersion -> $newVersion"
                ant.propertyfile(file: versionFile) {
                    entry(key: classifier, type: 'int', operation: '+', value: 1)
                }
            }
        }
}
通过运行gradle tasks会列出一个具体的tasks组rules：
task 规则不能分组，其显示在 Rules组下
#链接：https://www.jianshu.com/p/61bdec43c66f

```
* 在buildSrc目录下构建代码
Groovy代码放在src/main/groovy目录下；这些目录下代码会自动编译，并添加到Gradle构建脚本的classpath中
build.gradle中需要引入groovy插件
```
plugins {
    id 'groovy'}
dependencies {
    compile 'org.codehaus.groovy:groovy-all:3.0.0-rc-1' }
```
在当前 module下对应的 build.gradle文件，直接引入 buildSrc 下的类，这样Task定义与build.gradle分离了
```

import com.better.ProjectVersion2
import com.better.ReleaseVersionTask2
```
5.
* 生命周期钩子
whenReady方法
* 初始化构建环境
初始化脚本会在任何构建脚本逻辑解析执行之前运行，可以在$USER_HOME/.gradle/init.d中创建初始化脚本
gradle 会执行在init.d下以.gradle 为扩展名的所有初始化脚本。
```
// init.d下新建 build-load.gradle文件，也可以加到项目的setting.gradle中，仅对该项目起作用
gradle.projectsLoaded {
    println "初始化阶段 projectsLoaded"
}

```

 

